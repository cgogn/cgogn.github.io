---
title: Doc
---

# Foreword

The following documentation starts with an [Introduction](#introduction) to meshes and [Combinatorial maps](#combinatorial-maps), the underlying model used in CGoGN. Depending on your current understanding of this model and on the level on which you plan to use the library, you may or may not need to read it. So feel free to jump directly to the [Implementation](#implementation) part.

# Introduction

A __mesh__ is the cellular decomposition of geometric objects such as curves, surfaces or volumes. Mesh data structures are of fundamental importance in many fields such as surface modeling, mesh generation, finite element analysis, physical simulation, geometry processing, visualization or computational geometry.

__Topological models__ provide neighborhood relations between the cells of the decomposition (vertices, edges, faces, volumes). This information is mandatory for many algorithms in the mentioned application fields.

The data structure should:
 - provide an easy and efficient way to traverse the cells
 - provide an easy and efficient way to traverse local neighborhoods
 - allow to store data with the cells
 - provide operators to modify the connectivity
 - remain efficient both in memory & time even in complex highly dynamic settings

Many existing mesh data structures actually find their roots in the notion of __combinatorial map__, a mathematically defined structure that represents the subdivision of n-dimensional manifolds.

# Combinatorial maps

Combinatorial maps are __dimension-independent__ and rely on a single element along with a simple set of relations. All the information about the __cells__ and their __incidence__ and __adjacency__ relations is contained within this simple model. All neighborhood queries are resolved in optimal time (linear in the number of traversed cells) without having to maintain any additional information.

As in other topological models, there is a __strong separation__ between the __topological structure__ of the subdivision and the __attributes__ that can be associated to the cells.

## From incidence graph to cell-tuples

Figure 1 shows a simple cellular decomposition of a 2-dimensional object and its incidence graph that we use as a running example in our definition.

<p align="center">
	<img alt="Incidence graph" src="/assets/img/incidence_graph.png">
	<em>Figure 1: A cellular decomposition of a 2-dimensional object and its incidence graph</em>
</p>

In a n-dimensional cellular decomposition, a cell-tuple is defined as an ordered sequence of cells (Cn, Cn−1, ..., C1, C0) of decreasing dimensions such that ∀i, 0 < i ≤ n, Ci is incident to Ci−1. In other words, a cell-tuple corresponds to a path in the incidence graph from a n-cell to a 0-cell, i.e. a vertex. Figure 2 shows the iterative construction of all the cell-tuples generated by the cellular decomposition of Figure 1.

<p align="center">
	<img alt="Cell-tuples" src="/assets/img/cell_tuples.png">
	<em>Figure 2: Iterative construction of the cell-tuples corresponding to the cellular decomposition of Figure 1</em>
</p>

Adjacency relations are defined on the cell-tuples: two cell-tuples are said to be i-adjacent if their path in the incidence graph share all but the i-dimensional cell. For example, (F1, E2, V1) and (F1, E2, V2) are 0-adjacent. In the context of the cellular decomposition of a quasi-manifold, it can be shown that these n+1 adjacency relations put the cell-tuples in a one-to-one relation (except for the n-adjacency at the boundary of the object where cell-tuples do not have any mate). Based on these definitions, generalized maps (or G-maps) have been proposed as a model for the representation of the cellular decomposition of n-dimensional quasi-manifolds.

## Generalized maps

Generalized maps encode a cellular decomposition with a set D of abstract elements called darts that are in one-to-one correspondance with the cell-tuples. A set of n+1 functions αi : D → D, 0 ≤ i ≤ n are defined based on the i-adjacency relations of the cell-tuples. Figure 3 shows the G-map corresponding to the cellular decomposition of the previous example. Following the previously mentioned properties of i-adjacencies on cell-tuples, αi functions are involutions, i.e. functions such that ∀d ∈ D, αi(αi(d)) = d.

Combinatorial constraints express the correct assembly of cells along their boundary. For αi functions, these constraints are expressed as follows: ∀i, j, 0 ≤ i < i + 2 ≤ j ≤ n, αi ◦ αj is an involution. If the G-map is constructed from the incidence graph of the decomposition of a quasi-manifold – a set of d-cells glued along (d-1)-cells – then those constraints are automatically satisfied.

The original cells are thus decomposed with their incidence relations into a dimension-independent set of a unique abstract entity. In order to bring back the notion of cell, the following two observations are a good starting point:
 - each dart identifies a set of n cells of each dimension, i.e. those contained in the corresponding cell-tuple
 - each k-cell is represented by a set of darts, i.e. all the darts whose corresponding cell-tuple contains this cell

Figure 3 illustrates these notions. Starting from the same dart d, depending on how it is interpreted, one can build the set of darts that represent its vertex, edge or face. Within each of these sets, any dart equally represents the corresponding vertex, edge or face.

<p align="center">
	<img alt="Generalized map" src="/assets/img/gmap.png">
	<em>Figure 3: The top figure shows the G-map corresponding to the cellular decomposition of Figure 1. Darts are represented like the cell-tuples in Figure 2; α0, α1 and α2 functions are represented respectively by blue, green and red links. The three bottom figures illustrate the sets of darts representing the vertex, edge and face of dart d.</em>
</p>

Now we only need a way to construct these sets of darts. Following the previous definitions, αi(d) is the dart that represents the same cells as d except from the i-dimensional cell. All the other αj , j = i functions will lead to darts that share the same i-cell as d. It follows that starting from a dart, the set of darts representing the same i-cell can be obtained by applying successively all the functions that maintain the i-dimensional cell unchanged, i.e. { αj, j ∈ {0, 1, ..., i−1, i+1, ..., n} }. Such sets of darts are formally defined as orbits, noted: < α0, ..., αi−1, αi+1, ..., αn >. For example in Figure 3, the vertex, edge and face of d are defined respectively by the following orbits: < α1, α2 > (d), < α0, α2 > (d) and < α0, α1 > (d).

## Oriented combinatorial maps

A G-map is able to represent orientable or non-orientable quasi-manifolds. However, a representation domain restricted to orientable objects is sufficient in many application contexts. In this case, a more compact model can be used. The orientability of a given G-map can be determined with a binary coloring process of its darts following this rule: a dart of a given color can only be linked to darts of the other color. Starting with an arbitrary dart, if the whole object can be colored this way, then the object is orientable. In this case, the darts of the G-map are partitionned in two sets D-black and D-white of equal cardinality, each one representing one of the two orientations of the object. For any dart d ∈ D, < φ1, ..., φn > (d) with φi = αi ◦ α0 is the set of darts corresponding to the orientation yielded by d. For example, if d ∈ D-black, then < φ1, ..., φn > (d) = D-black. Figure 4 shows the application of this process.

<p align="center">
	<img alt="Oriented map" src="/assets/img/oriented_gmap.png">
	<em>Figure 4: Left: the darts of the G-map have been partitionned in two sets, each corresponding to one of the two orientations of the object. Right: the oriented combinatorial map yielded by dart d; φ1 = α1 ◦ α0 and φ2 = α2 ◦ α0 relations are represented respectively by blue-green and blue-red links.</em>
</p>

As they represent the exact same object, keeping the two orientations of an orientable G-map is not necessary and one of these sets can be dropped, leading to a twice more compact representation. One orientation of an orientable G-map is actually a combinatorial map, defined as a set of darts D along with n functions φi : D → D, 1 ≤ i ≤ n, with φi = αi ◦ α0. The φ1 function is a permutation that links the ordered vertices around oriented faces. The φi, i ≤ 2 ≤ n functions are involutions, as stated by the constraint expressed above on the αi involutions. From a constructive point of view, each of these involutions allows to glue pairs of i-dimensional cells along their common (i-1)-dimensional boundary cell.

The orbits that define the cells are the following. For cells of dimension i ≥ 1, the sets of darts that represent the cells are defined by the orbit < φ1, ..., φi−1, φi+1, ..., φn >. Like for G-maps, starting from any dart, all the functions that maintain the i-dimensional cell unchanged are applied. For vertices, the orbit is < φ1 ◦ φ2, ..., φ1 ◦ φn >.

## Embedding

Maps and G-maps only define the topology of the cellular decomposition of quasi-manifolds, i.e. the cells – represented implicitly by sets of darts – and the neighborhood relations between them. In order to consistently attach attributes to cells, any data attached to a cell has to be linked to all the darts of this cell. The most flexible solution is to associate an index to each cell. Any data associated to this index is then associated to the corresponding cell.

To model this idea, additional functions can be defined on maps. For each i, 0 ≤ i ≤ n, emb\_i : D → N, is the function that associates to each dart the index of its i-dimensional cell. In order for a map to be well embedded, the following constraint must be satisfied: ∀d, d ∈ D, ∀d' ∈ orbit\_i(d), emb\_i(d') = emb\_i(d). In other words, for each dimension, all the darts of the same orbit are associated to the same index.

The indexing of the cells of any dimension is completely optional. If the cells of one or even all dimensions are not indexed, the cellular decomposition and its topology are still completely defined. Indeed, cell enumeration and neighborhood traversals are performed using exclusively the darts and their relations.

# Implementation

CGoGN provides an efficient C++ implementation of oriented combinatorial maps. Its main features are combinatorial maps representation, manipulation, traversal and a dynamic attribute mechanism. It is also designed to take advantage of parallel architectures.

## Attribute containers

The central data structure used in CGoGN is __attribute containers__. An attribute container is a set of __attributes__ of arbitrary type that all have the same number of records. Attributes can be dynamically added and removed in an attribute container. An index identifies a tuple of records, one in each attribute of the container. Records can be dynamically added and removed in an attribute container. Removed entries are actually only marked as removed and skipped during the traversals. They are left available for further record additions.

Each __attribute__ is stored as a chunk array, i.e. a set of fixed size arrays. It allows the size of the attribute to grow while leaving all existing elements in place. Chunk size is chosen as a power of 2 so that the arithmetic operations needed to access the record of a given index (division and modulo) are very efficient.

A map in CGoGN is encoded as a set of attribute containers. The only mandatory container is the Dart container. According to the dimension of the map, it stores a variable number of attributes that encode the topological relations φ1, ..., φn. Each dart being represented by its index in the Dart container, these attributes store indices of linked darts in the Dart container. For each embedded cell dimension, the Dart container maintains an attribute that stores for each dart the index of its corresponding cell orbit. These indices correspond to entries in a dedicated attribute container. For example, in the map illustrated in Figure 5, Vertex and Face cells are embedded. The Dart container maintains _V_ and _F_ attributes that store the Vertex and Face index of each dart. Obviously, as explained in the [embedding](#embedding) section, all the darts of a same orbit share the same index. The Vertex and Face attribute containers store the data associated with each vertex and face cell of the map.

<p align="center">
	<img alt="Containers" src="/assets/img/containers.png">
	<em>Figure 5: Containers of a 2-dimensional combinatorial map with vertex and face embedding. The dart container stores φ1 and φ2 indices of linked darts and V and F indices of the associated vertices and faces attributes.</em>
</p>

## Basic types

CGoGN defines symbols in the `cgogn` namespace which will be omitted in the following.

The most basic type defined in CGoGN is `Dart` which stores an index in the Dart container.

An enumeration of orbits is also defined. These orbits correspond to the different cells that can be defined in a combinatorial map. They are defined as follows:
```c++
enum Orbit: uint32
{
    DART = 0,      // 1d vertex
    PHI1,          // 1d cycle, 2d face
    PHI2,          // 2d edge
    PHI21,         // 2d vertex
    PHI1_PHI2,     // 2d connected component, 3d volume
    PHI1_PHI3,     // 3d face
    PHI2_PHI3,     // 3d edge
    PHI21_PHI31,   // 3d vertex
    PHI1_PHI2_PHI3 // 3d connected component
};
```

The `Cell<Orbit>` template class stores a Dart that is publicly available as a `dart` property. These cell types can actually be seen as orbit-typed Darts.

A combinatorial map is composed of a Dart container and a container for each of the orbits defined in the above enumeration. These containers can be used to store the attributes associated to the cells of each embedded orbit. Containers corresponding to non-embedded orbits will remain unused during the lifetime of the map.

Several map types are defined (one for each dimension). For example, a 2-dimensional combinatorial map can be declared like that: `CMap2 map;`.

Each map type provides several convenience internal definitions for its cells types. For example a `CMap2` provides the following cell types: `CMap2::Vertex`, `CMap2::Edge`, `CMap2::Face`, `CMap2::Volume`. These cells are actually defined respectively as: `Cell<Orbit::PHI21>`, `Cell<Orbit::PHI2>`, `Cell<Orbit::PHI1>`, `Cell<Orbit::PHI1_PHI2>` which correspond to the orbits of these cells in a 2-dimensional map.

A `CMap2::Vertex v` contains a Dart and can be thought of as the vertex of `v.dart`. Any other Dart of the same vertex orbit could equally represent the same cell.

## Attributes

Attributes of any type can be added in a map. The `Attribute<T, Orbit>` template class provides a way to access to the type `T` values associated to the `Cell<Orbit>` cells of a map. Here again, convenience definitions are provided in the map types: `CMap2::VertexAttribute<T>`, `CMap2::EdgeAttribute<T>`, etc.

For example, a Vertex attribute storing an integer value on each vertex can be added in a 2-dimensional map like that:
```c++
CMap2 map;
CMap2::VertexAttribute<uint32> attr = map.add_attribute<uint32, CMap2::Vertex>("attr");
```

An existing attribute can also be obtained by its name. As the requested attribute may not exist in the map, the validity of the obtained object can then be verified:
```c++
CMap2::FaceAttribute<double> area = map.get_attribute<double, CMap2::Face>("area");
if (!area.is_valid())
{
    // there were no Face attribute of this type having this name in the map
}
```

Attribute values can be traversed globally using the range-based for loop syntax:
```c++
for (const T& v : attr)
{
    // do something with v
}
```

Given a cell of the map, the value associated to this cell for an attribute can be directly accessed using the bracket operator:
```c++
// given two CMap2::Face f1, f2
area[f1] = 3.4;
double sum = area[f1] + area[f2];
```

Under the hood, this operator will first query the embedding index of the given cell and then access to the value stored at this index in the corresponding Cell attribute container. The embedding index of a cell does not depend on the accessed attribute. As the bracket operator can also be given directly the index of the cell, in the case of accessing to multiple attributes for a same cell, it can be more efficient to first get the embedding index, and then directly use this index to access to the different values associated to the cell:
```c++
// given a CMap2::Face f
uint32 findex = map.embedding(f);
attr1[findex] = attr2[findex] + attr3[findex];
```

Attributes can also easily be removed from a map:
```c++
map.remove_attribute(attr);
```

## Global traversals

The cells of the map can be traversed using the `foreach_cell` method. This method takes a callable that expects a `Cell<Orbit>` as parameter. It is the type of this parameter that determines the type of the cells that will be traversed by the foreach method. For example, the following code will traverse the vertices of the map and call the given lambda expression on each vertex:
```c++
// given a CMap2 map
map.foreach_cell([&] (CMap2::Vertex v)
{
    // do something with v
});
```

No assumption can be made here about the `Dart` that represents each cell (e.g. `v.dart` in the previous example) when the processing function is called. Any dart of the same orbit could equally represent the same cell.

### Early stop

In order to stop the traversal before all the cells have been processed, the provided callable can return a boolean value. As soon as the callable returns false, the traversal is stopped. In the following example, we are looking for the first encountered vertex for which the Vec3 position value is on the negative side of the x=0 plan. If after the traversal, the declared Vertex is not valid, it means such a vertex has not been found in the map:
```c++
// given a CMap2 map
// given a CMap2::VertexAttribute<Vec3> position
CMap2::Vertex looked_up_v;
map.foreach_cell([&] (CMap2::Vertex v) -> bool
{
    if (position[v][0] < 0.0)
    {
        looked_up_v = v;
        return false;
    }
    return true;
});
if (!looked_up_v.is_valid())
{
    // no such vertex was found
}
```

### Parallelism

CGoGN can take advantage of parallel architectures to speed-up global traversals. A parallel traversal of the cells can be done using the `parallel_foreach_cell` method. The processing of the cells of the map will be spread among a number of threads that depends on the detected underlying hardware concurrency. In the following example, the displacement value value of each vertex is added to its position:
```c++
// given a CMap2 map
// given two CMap2::VertexAttribute<Vec3> position, displacement
map.parallel_foreach_cell([&] (CMap2::Vertex v)
{
    position[v] += displacement[v];
});
```

It is also possible to aggregate results coming from the parallel processing of several threads. In the following example, the average value of an Edge attribute is computed in parallel. Each thread accumulates the values and number of elements corresponding to the fraction of the mesh that it processes, and then the global result is computed:
```c++
// given a CMap2 map
// given a CMap2::EdgeAttribute<double> length

std::vector<double> sum_per_thread(thread_pool()->nb_workers(), 0.0);
std::vector<uint32> nb_per_thread(thread_pool()->nb_workers(), 0);

map.parallel_foreach_cell([&] (CMap2::Edge e)
{
    uint32 thread_index = current_thread_index();
    sum_per_thread[thread_index] += length[e];
    nb_per_thread[thread_index]++;
});

double sum = 0.0;
for (double d : sum_per_thread) sum += d;
uint32 nb = 0;
for (uint32 n : nb_per_thread) nb += n;

double average = sum / double(nb);
```

Note that early stop is not available when doing parallel traversals.

### Masks

In their simplest form, the `foreach_cell` and the `parallel_foreach_cell` methods process all the cells of the map. A second parameter, which we call a __Mask__ can be given to these methods and alter the way they work.

##### Filtering functions

The most simple Mask takes the form of a callable, that takes as parameter the same type of Cell than the _processing_ callable. This _filtering_ callable returns a boolean value, and for each cell of the map, the _processing_ callable will be called only if the _filtering_ callable evaluated to true.

In the following example, the function will print only the faces for which the area is above a given threshold:
```c++
void print_faces(const CMap2& map, const CMap2::FaceAttribute<double>& area, double threshold)
{
    map.foreach_cell(
        [] (CMap2::Face f) { std::cout << f << std::endl; },
        [&] (CMap2::Face f) -> bool { return area[f] > threshold; }
    );
}
```

Of course, things become much more interesting and reusable when the function takes the map and a Mask, and describes its processing without even knowing how the Mask is altering the traversal:
```c++
template <typename MASK>
void print_faces(const CMap2& map, const MASK& mask)
{
    map.foreach_cell(
        [] (CMap2::Face f) { std::cout << f << std::endl; },
        mask
    );
}
```

The filtering Mask can then be defined on-the-fly when calling the function, using any local data to do its work:
```c++
// given a CMap2 map
// given a CMap2::FaceAttribute<double> area
// given a double value threshold
print_faces(map, [&] (CMap2::Face f) -> bool { return area[f] > threshold; });
```

##### Cell filters

There are cases in which a function has to traverse several types of cells. Passing an additional Mask parameter for each type of cell would not be a very versatile solution. That is why the `foreach_cell` and `parallel_foreach_cell` methods can also accept an object derived from the `CellFilters` class as their second parameter.

Such an object defines a filtering function for each type of filtered cell. The following example shows a simple filtering object definition. The object is constructed given a map and a boolean vertex attribute. The filtered cells are here vertices for which the attribute is true and edges for which the attribute is true for its two incident vertices:
```c++
class SelectedCells : public CellFilters
{
public:
    SelectedCells(const CMap2& m, const CMap2::VertexAttribute<bool>& s) :
        map_(m), selected_(s)
    {}

    inline bool filter(CMap2::Vertex v) const
    {
        return selected_[v];
    }

    inline bool filter(CMap2::Edge v) const
    {
        return selected[CMap2::Vertex(v.dart)] && selected_[CMap2::Vertex(map_.phi2(v.dart))];
    }

    inline uint32 filtered_cells() const
    {
        return orbit_mask<CMap2::Vertex>() | orbit_mask<CMap2::Edge>();
    }

private:
    const CMap2& map_;
    const VertexAttribute<bool>& selected_;
};
```

Such a filtering object can then be used like follows:
```c++
// given a CMap2 map
// given a CMap2::VertexAttribute<bool> selected

template <typename MASK>
void f(const CMap2& map, const MASK& mask)
{
    map.parallel_foreach_cell(
        [] (CMap2::Vertex v) { /* do something */ },
        mask
    );
    map.parallel_foreach_cell(
        [] (CMap2::Edge e) { /* do something */ },
        mask
    );
}

SelectedCells sc(map, selected);
f(map, sc);
```

As you can see, an additional `filtered_cells` method is defined in the `CellFilters` objects. It is used by the `foreach_cell` or `parallel_foreach_cell` method to check that the requested cell traversal is actually filtered by the given object. If it is not the case, a warning is printed.

##### Cell traversors

Filtering functions are a great and versatile way to customize cell traversals. They are particularly well adapted to highly variable settings where the set of filtered cells changes regularly w.r.t. the filtering function. However, under the hood, the complete map is still traversed using classical algorithms that enumerate the darts and use markers (a boolean attribute) to tag the darts of the processed orbits.

Other types of objects, derived from the `CellTraversor` class, can be used as a Mask and given as a second parameter to the `foreach_cell` or `parallel_foreach_cell` method. Any `CellTraversor` should provide a `begin<CellType>` and `end<CellType>` template methods that return an internal `const_iterator` type instance. These methods are then used by the `foreach_cell` or `parallel_foreach_cell` method to completely overload the classical traversal. Several `CellTraversors` are already provided in CGoGN.

__QuickTraversor__

The goal of a `QuickTraversor` is to avoid the traversal of the darts and the marking/unmarking cost related to the usage of a marker. To this aim, it creates an Attribute of type Dart in the attribute container of the traversed cell type. Calling the `build<CellType>` method will fill this attribute with one representing dart per cell. When the `QuickTraversor` is given to the `foreach_cell` or `parallel_foreach_cell` method, its internal attribute is used to directly enumerate the cells without having to manage any marker, providing a significative speed-up.

However,  in order to keep the `QuickTraversor` in sync with the map, special care must be taken when the connectivity is modified:
 - when a new orbit is created, one of its darts has to be written in the internal attribute. This can be done by passing the new cell to the `update` method.
 - when an existing orbit is modified, if one or more darts have been removed, the representing dart stored in the internal attribute may have been removed. A valid dart can be chosen again by passing the cell to the `update` method.
 - when an orbit is completely deleted, nothing has to be done as the attributes of this cell will not be traversed anymore.

In the following example, a `QuickTraversor` is built for the vertices of the map. Then an edge is cut, inserting a new vertex, for which the `QuickTraversor` is updated:
```c++
// given a CMap2 map
CMap2::QuickTraversor qtrav(map);
qtrav.build<CMap2::Vertex>();
map.foreach_cell(
    [&] (CMap2::Vertex v) { /* do something with v */ },
    qtrav
);
// given a CMap2::Edge e
CMap2::Vertex v = map.cut_edge(e);
qtrav.update(v);
```

The selection of the dart that represents each cell can be customized by giving an additional function as a last parameter to the `build` and `update` methods. This function should take a Cell and return a Dart. This customization is a great way to be able to make assumptions about the dart that represents each cell when it is given to the processing function during a traversal.

__FilteredQuickTraversor__

A `FilteredQuickTraversor` is a variation of a `QuickTraversor` in which a filtering function is given to the `build` function. The internal attribute is still filled with one dart per cell and the same updates have to be done in order to keep it in sync with the map. The difference is that the provided filter will be evaluated dynamically each time the `FilteredQuickTraversor` is used for the traversal of the cells.

The dart selection feature is also available by giving a function as a last parameter to the `build` and `update` methods.

__CellCache__

With the previous Masks, even when using a filtering function, all the cells of the map are always traversed and the filtering function is evaluated dynamically on each cell in order to decide to call the processing function on it or not. This can be great in a dynamic environment where the set of filtered cells changes regularly. But if the set of filtered cells is stable, and moreover if this set is small w.r.t. the number of cells of the map, a more efficient solution can be proposed.

A `CellCache` can store a set of cells for each type of cell. These sets will be directly traversed by the `foreach_cell` or `parallel_foreach_cell` method. Its main public method is `build<CellType>` which builds the set of the mentioned cell type.

If no argument is given, all the cells of the map will be put into the cache. However, the build method can also take a Mask as an optional argument to restrict the cached cells to the ones that are visible with the given Mask. Any kind of supported Mask, i.e. a filtering function, a `CellFilter` or a `CellTraversor` (but not the one we are trying to build) can be used.

In the following example, all the degree 5 vertices are put into a cache which is then used in a traversal that is efficient and restricted to those vertices:
```c++
// given a CMap2 map
CMap2::CellCache cache(map);
cache.build<CMap2::Vertex>([&] (CMap2::Vertex v)
{
    return map.degree(v) == 5;
});
map.foreach_cell(
    [&] (CMap2::Vertex v) { /* do something with v */ },
    cache
);
```

Note that if a new degree 5 vertex is inserted into the map, it will not be part of a cache that has been built before.

Note also that if any cell stored in the cache is deleted from the map, the cache is invalid and any subsequent traversal with this `CellCache` will fail.

A common usage of `CellCache` is with algorithms that insert new cells into the traversed map. Indeed, without such a mechanism, the newly inserted cells would be traversed resulting in a possible infinite loop. In the following example, all existing edges of the map are cut by inserting a new vertex:
```c++
// given a CMap2 map
CMap2::CellCache cache(map);
cache.build<CMap2::Edge>();
map.foreach_cell([&] (CMap2::Edge e) { map.cut_edge(e); }, cache );
``` 

## Local traversals



## Operators

