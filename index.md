---
title: Doc
---

## Foreword

The following documentation starts with an [Introduction](#introduction) to meshes and combinatorial maps, the underlying model used in CGoGN. Depending on your current understanding of this model and on the level on which you plan to use the library, you may or may not need to read it. So feel free to jump directly to the [Implementation](#implementation) part.

## Introduction

A __mesh__ is the cellular decomposition of geometric objects such as curves, surfaces or volumes.

Mesh data structures are of fundamental importance in many fields such as surface modeling, mesh generation, finite element analysis, physical simulation, geometry processing, visualization or computational geometry.

__Topological models__ provide neighborhood relations between the cells of the decomposition (vertices, edges, faces, volumes). This information is mandatory for many algorithms in the mentioned application fields.

The data structure should:
 - provide an easy and efficient way to traverse the cells
 - provide an easy and efficient way to traverse local neighborhoods
 - allow to store data with the cells
 - provide operators to modify the connectivity
 - remain efficient both in memory & time even in complex highly dynamic settings

Many existing mesh data structures actually find their roots in the notion of __combinatorial map__, a mathematically defined structure that represents the subdivision of n-dimensional manifolds.

## Combinatorial maps

Combinatorial maps are dimension-independent and rely on a single element along with a simple set of relations. All the information about the cells and their incidence and adjacency relations is contained within this simple model. All neighborhood traversals are resolved in optimal time (linear in the number of traversed cells) without having to maintain any additional information.

As in other topological models, there is a strong separation between the topological structure of the subdivision and the attributes that can be associated to the cells.

### From incidence graph to cell-tuples

Figure 1 shows a simple cellular decomposition of a 2-dimensional object and its incidence graph that we use as a running example in our definition.

<p align="center">
	<img alt="Incidence graph" src="/assets/img/incidence_graph.png">
	<em>Figure 1: A cellular decomposition of a 2-dimensional object and its incidence graph</em>
</p>

In a n-dimensional cellular decomposition, a cell-tuple is defined as an ordered sequence of cells (Cn, Cn−1, ..., C1, C0) of decreasing dimensions such that ∀i, 0 < i ≤ n, Ci is incident to Ci−1. In other words, a cell-tuple corresponds to a path in the incidence graph from a n-cell to a 0-cell, i.e. a vertex. Figure 2 shows the iterative construction of all the cell-tuples generated by the cellular decomposition of Figure 1.

<p align="center">
	<img alt="Cell-tuples" src="/assets/img/cell_tuples.png">
	<em>Figure 2: Iterative construction of the cell-tuples corresponding to the cellular decomposition of Figure 1</em>
</p>

Adjacency relations are defined on the cell-tuples: two cell-tuples are said to be i-adjacent if their path in the incidence graph share all but the i-dimensional cell. For example, (F1, E2, V1) and (F1, E2, V2) are 0-adjacent. In the context of the cellular decomposition of a quasi-manifold, it has been shown that these n+1 adjacency relations put the cell-tuples in a one-to-one relation (except for the n-adjacency at the boundary of the object where cell-tuples do not have any mate). Based on these definitions, generalized-maps (or G-maps) have been proposed as a model for the representation of the cellular decomposition of n-dimensional quasi-manifolds.

### Generalized maps

Generalized maps encode a cellular decomposition with a set D of abstract elements called darts that are in one-to-one correspondance with the cell-tuples. A set of n+1 functions αi : D → D, 0 ≤ i ≤ n are defined based on the i-adjacency relations of the cell-tuples. Figure 3 shows the G-map corresponding to the cellular decomposition of previous example. Following the previously mentioned properties of i-adjacencies on cell-tuples, αi functions are involutions, i.e. functions such that ∀d ∈ D, αi(αi(d)) = d.

Combinatorial constraints express the correct assembly of cells along their boundary. For αi functions, these constraints are expressed as follows: ∀i, j, 0 ≤ i < i + 2 ≤ j ≤ n, αi ◦ αj is an involution. If the G-map is constructed from the incidence graph of the decomposition of a quasi-manifold – a set of d-cells glued along (d-1)-cells – then those constraints are automatically satisfied.

The original cells are thus decomposed with their incidence relations into a dimension-independent set of a unique abstract entity. In order to bring back the notion of cell, the following two observations are a good starting point:
 - each dart identifies a set of n cells of different dimension, i.e. those contained in the corresponding cell-tuple
 - each k-cell is represented by a set of darts, i.e. all the darts whose corresponding cell-tuple contains this cell

Figure 3 illustrates these notions. Starting from the same dart d, depending on how it is interpreted, one can build the set of darts that represent its vertex, edge or face. Within each of these sets, any dart equally represents the corresponding vertex, edge or face.

<p align="center">
	<img alt="Generalized map" src="/assets/img/gmap.png">
	<em>Figure 3: The top figure shows the G-map corresponding to the cellular decomposition of Figure 1. Darts are represented like the cell-tuples in Figure 2; α0, α1 and α2 functions are represented respectively by blue, green and red links. The three bottom figures illustrate the sets of darts representing the vertex, edge and face of dart d.</em>
</p>

Now we only need a way to construct these sets of darts. Following the previous definitions, αi(d) is the dart that represents the same cells as d except from the i-dimensional cell. All the other αj , j = i functions will lead to darts that share the same i-cell as d. It follows that starting from a dart, the set of darts representing the same i-cell can be obtained by applying successively all the functions that maintain the i-dimensional cell unchanged, i.e. { αj, j ∈ {0, 1, ..., i−1, i+1, ..., n} }. Such sets of darts are formally defined as orbits, noted: < α0, ..., αi−1, αi+1, ..., αn >. For example in Figure 3, the vertex, edge and face of d are defined respectively by the following orbits: < α1, α2 > (d), < α0, α2 > (d) and < α0, α1 > (d).

### Oriented combinatorial maps

A G-map is able to represent orientable or non-orientable quasi-manifolds. However, a representation domain restricted to orientable objects is sufficient in many application contexts. In this case, a more compact model can be used. The orientability of a given G-map can be determined with a binary coloring process of its darts following this rule: a dart of a given color can only be linked to darts of the other color. Starting with an arbitrary dart, if the whole object can be colored this way, then the object is orientable. In this case, the darts of the G-map are partitionned in two sets D-black and D-white of equal cardinality, each one representing one of the two orientations of the object. For any dart d ∈ D, < φ1, ..., φn > (d) with φi = αi ◦ α0 is the set of darts corresponding to the orientation yielded by d. For example, if d ∈ D-black, then < φ1, ..., φn > (d) = D-black. Figure 4 shows the application of this process.

<p align="center">
	<img alt="Oriented map" src="/assets/img/oriented_gmap.png">
	<em>Figure 4: Left: the darts of the G-map have been partitionned in two sets, each corresponding to one of the two orientations of the object. Right: the oriented combinatorial map yielded by dart d; φ1 = α1 ◦ α0 and φ2 = α2 ◦ α0 relations are represented respectively by blue-green and blue-red links.</em>
</p>

As they represent the exact same object, keeping the two orientations of an orientable G-map is not necessary and one of these sets can be dropped, leading to a twice more compact representation. One orientation of an orientable G-map is actually a combinatorial map, defined as a set of darts D along with n functions φi : D → D, 1 ≤ i ≤ n, with φi = αi ◦ α0. The φ1 function is a permutation that links the ordered vertices around oriented faces. The φi, i ≤ 2 ≤ n functions are involutions, as stated by the constraint expressed above on the αi involutions. From a constructive point of view, each of these involutions allows to glue pairs of i-dimensional cells along their common (i-1)-dimensional boundary cell.

The orbits that define the cells are the following. For cells of dimension i ≥ 1, the sets of darts that represent the cells are defined by the orbit < φ1, ..., φi−1, φi+1, ..., φn >. Like for G-maps, starting from any dart, all the functions that maintain the i-dimensional cell unchanged are applied. For vertices, the orbit is < φ1 ◦ φ2, ..., φ1 ◦ φn >.

### Embedding

Maps and G-maps only define the topology of the cellular decomposition of quasi-manifolds, i.e. the cells – represented implicitly by sets of darts – and the neighborhood relations between them. In order to consistently attach attributes to cells, any data attached to a cell has to be linked to all the darts of this cell. The most flexible solution is to associate an index to each cell. Any data associated to this index is then associated to the corresponding cell.

To model this idea, additional functions can be defined on maps. For each i, 0 ≤ i ≤ n, emb\_i : D → N, is the function that associates to each dart the index of its i-dimensional cell. In order for a map to be well embedded, the following constraint must be satisfied: ∀d, d ∈ D, ∀d' ∈ orbit\_i(d), emb\_i(d') = emb\_i(d). In other words, for each dimension, all the darts of the same orbit are associated to the same index.

The indexing of the cells of any dimension is completely optional. If the cells of one or even all dimensions are not indexed, the cellular decomposition and its topology are still completely defined. Indeed, cell enumeration and neighborhood traversals are performed using exclusively the darts and their relations.

## Implementation

CGoGN provides an efficient C++ implementation of oriented combinatorial maps. Its main features are combinatorial maps representation, manipulation, traversal and a dynamic attribute mechanism. It is also designed to take advantage of parallel architectures.

### Attribute containers

The central data structure used in CGoGN is __attribute containers__. An attribute container is a set of __attributes__ of arbitrary type that all have the same number of records. Attributes can be dynamically added and removed in an attribute container. An index identifies a tuple of records, one in each attribute of the container. Records can be dynamically added and removed in an attribute container. Removed entries are actually only marked as removed and skipped during the traversals. They are left available for further record additions.

Each __attribute__ is stored as a chunk array, i.e. a set of fixed size arrays. It allows the size of the attribute to grow while leaving all existing elements in place. Chunk size is chosen as a power of 2 so that the arithmetic operations needed to access the record of a given index (division and modulo) are very efficient.

A map in CGoGN is encoded as a set of attribute containers. The only mandatory container is the Dart container. According to the dimension of the map, it stores a variable number of attributes that encode the topological relations φ1, ..., φn. Each dart being represented by its index in the Dart container, these attributes store indices of linked darts in the Dart container. For each embedded cell dimension, the Dart container maintains an attribute that stores for each dart the index of its corresponding cell orbit. These indices correspond to entries in a dedicated attribute container. For example, in the map illustrated in Figure 5, Vertex and Face cells are embedded. The Dart container maintains _V_ and _F_ attributes that store the Vertex and Face index of each dart. Obviously, as explained in the [embedding](#embedding) section, all the darts of a same orbit share the same index. The Vertex and Face attribute containers store the data associated with each vertex and face cell of the map.

<p align="center">
	<img alt="Containers" src="/assets/img/containers.png">
	<em>Figure 5: Containers of a 2-dimensional combinatorial map with vertex and face embedding. The dart container stores φ1 and φ2 indices of linked darts and V and F indices of the associated vertices and faces attributes.</em>
</p>

### Basic types

CGoGN defines symbols in the `cgogn` namespace which will be omitted in the following.

The most basic type defined in CGoGN is `Dart` which stores an index in the Dart container.

An enumeration of orbits is also defined. These orbits correspond to the different cells that can be defined in a combinatorial map. They are defined as follows:
```c++
enum Orbit: uint32
{
    DART = 0,      // 1d vertex
    PHI1,          // 1d cycle, 2d face
    PHI2,          // 2d edge
    PHI21,         // 2d vertex
    PHI1_PHI2,     // 2d connected component, 3d volume
    PHI1_PHI3,     // 3d face
    PHI2_PHI3,     // 3d edge
    PHI21_PHI31,   // 3d vertex
    PHI1_PHI2_PHI3 // 3d connected component
};
```

The `Cell<Orbit>` template class stores a Dart. These cell types can actually be seen as orbit-typed Darts.

A combinatorial map is composed of a Dart container and a container for each of the orbits defined in the above enumeration. These containers can be used to store the attributes associated to the cells of each embedded orbit. Containers corresponding to non-embedded orbits will remain unused during the lifetime of the map.

Several map types are defined (one for each dimension). For example, a 2-dimensional combinatorial map can be declared like that: `CMap2 map;`.

Each map type provides several convenience internal definitions for its cells types. For example a `CMap2` provides the following cell types: `CMap2::Vertex`, `CMap2::Edge`, `CMap2::Face`, `CMap2::Volume`. These cells are actually defined respectively as: `Cell<Orbit::PHI21>`, `Cell<Orbit::PHI2>`, `Cell<Orbit::PHI1>`, `Cell<Orbit::PHI1_PHI2>` which correspond to the orbits of these cells in a 2-dimensional map.

### Attributes

Attributes of any type can be added in a map. The `Attribute<T, Orbit>` template class provides a way to access to the type `T` values associated to the `Cell<Orbit>` cells of a map. Here again, convenience definitions are provided in the map types: `CMap2::VertexAttribute<T>`, `CMap2::EdgeAttribute<T>`, etc.

For example, a Vertex attribute storing an integer value on each vertex can be added in a 2-dimensional map like that:
```c++
CMap2 map;
CMap2::VertexAttribute<uint32> attr = map.add_attribute<uint32, CMap2::Vertex>("attr");
```

An existing attribute can also be obtained by its name. As the requested attribute may not exist in the map, the validity of the obtained object can then be verified:
```c++
CMap2::FaceAttribute<double> area = map.get_attribute<double, CMap2::Face>("area");
if (!area.is_valid())
{
    // there were no Face attribute of this type having this name in the map
}
```

Attribute values can be traversed globally using the range-based for loop syntax:
```c++
for (const T& v : attr)
{
    // do something with v
}
```

Given a cell of the map, the value associated to this cell for an attribute can be directly accessed using the bracket operator:
```c++
// given two CMap2::Face f1, f2
area[f1] = 3.4;
double sum = area[f1] + area[f2];
```

Under the hood, this operator will first get the embedding index of the cell and then access to the value stored at this index in the corresponding Cell attribute container. The embedding index of a cell does not depend on the accessed attribute. As the bracket operator can also be given directly the index of the cell, in the case of accessing to multiple attributes for a same cell, it can be more efficient to first get the embedding index, and then directly use this index to access to the values associated to the cell:
```c++
// given a CMap2::Face f
uint32 findex = map.embedding(f);
attr1[findex] = attr2[findex] + attr3[findex];
```

### Global traversals

The cells of the map can be traversed using the `foreach_cell` method. This method takes a callable that expects a `Cell<Orbit>` as parameter. The type of this parameter determines the type of the cells that will be traversed by the foreach method. For example, the following call will traverse the vertices of the map and call the given lambda expression on each vertex:
```c++
// given a CMap2 map
map.foreach_cell([&] (CMap2::Vertex v)
{
    // do something with v
});
```

#### Early stop

If one wants to stop the traversal before all the cells have been processed, the provided callable has to return a boolean value. As soon as the callable returns false, the traversal is stopped. In the following example, we are looking up for the first encountered vertex for which the Vec3 position value is on the negative side of the x=0 plan. If after the traversal, the declared Vertex is not valid, it means such a vertex has not been found in the map:
```c++
// given a CMap2 map
// given a CMap2::VertexAttribute<Vec3> position
CMap2::Vertex lookedUpV;
map.foreach_cell([&] (CMap2::Vertex v) -> bool
{
    if (position[v][0] < 0.0)
	{
        lookedUpV = v;
        return false;
    }
    return true;
});
if (!lookedUpV.is_valid())
{
	// no such vertex was found
}
```

#### Parallelism



#### Filters



#### Traversors
